Авторы данной страницы: Шуруб Игорь (https://github.com/igorshurub) и Заднепрянская Алисия (https://github.com/ZadnepryanskayaAlicia)
# XSS уязвимости (Cross-Site Scripting — межсайтовый скриптинг)
## Теория
### Определение
XSS (англ. Cross-Site Scripting – «межсайтовый скриптинг») встречается в веб-приложениях. Атаки XSS возникают из-за недостаточной фильтрации данных, отправляемых пользователем для вставки в веб-страницу. Суть уязвимости заключается в возможности внедрения кода на страницу, которую просматривают другие пользователи, и взаимодействии этого кода с веб-сервером злоумышленника.  Запуск скрипта предоставит злоумышленнику доступ к информации типа «Пользователь-сайт», при этом браузер будет думать, что код запущен из доверенного источника.
### Виды XSS
* 	**Stored XSS:**

Сохраненный межсайтовый скриптинг (также известный как XSS второго порядка или постоянный) возникает, когда приложение получает данные из ненадежного источника и включает эти данные в свои последующие HTTP-ответы небезопасным способом. Код запускается каждый раз, когда пользователь посещает конкретный сайт.

* 	**Reflected XSS:**

Отраженный XSS включает внедрение вредоносного исполняемого кода в HTTP-ответ. Вредоносный скрипт не находится в веб-приложении и не сохраняется. Браузер жертвы выполняет атаку только в том случае, если пользователь открывает веб-страницу или ссылку, созданную злоумышленником.

Один запрос и ответ браузера доставляет и выполняет полезную нагрузку атаки. Созданные параметры HTTP или URI содержат строку атаки, которую веб-приложение обрабатывает неправильно.
Особое внимание можно уделить соответствующим функциям приложения, таким как комментарии к сообщениям в блоге. Когда отправленное значение наблюдается в ответе, необходимо определить, действительно ли данные хранятся в разных запросах, а не просто отражаются в немедленном ответе.

Когда определили связи между точками входа и выхода в процессе обработки приложения, каждая ссылка должна быть специально протестирована, чтобы определить, присутствует ли сохраненная уязвимость XSS. Это включает в себя определение контекста в ответе, в котором отображаются сохраненные данные, и тестирование подходящих потенциальных полезных нагрузок XSS, применимых к этому контексту. На данный момент методология тестирования в целом такая же, как и для поиска отраженных уязвимостей XSS.

* 	**DOM XSS**

XSS на основе DOM, также известная как XSS типа 0, представляет собой атаку XSS, в которой полезная нагрузка атаки выполняется путем изменения DOM в браузере жертвы. Это приводит к тому, что клиент запускает код без ведома или согласия пользователя. Сама страница (т. е. HTTP-ответ) не изменится, но злонамеренное изменение в среде DOM приведет к тому, что клиентский код, содержащийся на странице, будет выполняться по-другому.

Это отличается от отраженных или сохраненных атак XSS, которые размещают полезную нагрузку на страницу ответа из-за уязвимостей на стороне сервера. DOM XSS – это уязвимость на стороне клиента.

* 	**Blind XSS**

Является частным случаем Stored XSS. Его отличительной чертой является то, что данные, вводимые злоумышленником, и сохраняемые на сервере, отображаются в другой части веб-приложения.

* 	**Self XSS**

Self-XSS (self cross-site scripting) – это атака социальной инженерии, используемая для получения контроля над веб-учетными записями жертв. При самостоятельной XSS-атаке жертва атаки неосознанно запускает вредоносный код в своем собственном веб-браузере, тем самым предоставляя личную информацию злоумышленнику, своего рода уязвимость, известная как межсайтовый скриптинг. Self-XSS работает путем обмана пользователей, также заставляя их копировать и вставлять вредоносный контент в консоль веб-разработчика их браузеров.


### Как проверить, к какому типу относится инъекция (Reflected, Stored, DOM, Self или Blind)

Чтобы проверить, к какому типу относится инъекция необходимо знать информацию об инъекции, а также их отличительные особенности (ключевые моменты).

В типе инъекции **Stored** существует возможность внедрения кода в веб-страницу, которую просматривают другие пользователи сайта. **Ключевой момент**: постоянные XSS не требуют от жертвы участия, ей достаточно просто открыть страницу с хранимой XSS. Как только жертва обращается к сохраненной информации, она вместе с информацией получает вредоносный скрипт. 

В типе инъекции **Reflected** данные возвращаются пользователю сразу и при этом не проверяются. **Также ключевой момент**: атака не сработает, пока злоумышленник не отправит ссылку другим пользователям сайта.

В типе **DOM** инъекция осуществляется в параметры структуры DOM, в частности document.url, document.location и document.referrer. Общий принцип в целом совпадает с предыдущими (происходит запуск кода без его проверки). **Но ключевой момент**: нельзя отследить наличие кода инъекции в отображаемой HTML-странице, т.к. вредоносный скрипт не уходит на сервер, а выполняется (и может оставаться) непосредственно в браузере пользователя.

В типе инъекции **SELF** только сам пользователь сайта может выполнить код, который приводит к XSS. **Ключевой момент:** чтобы эксплуатировать Self XSS, злоумышленник должен заставить пользователя выполнить нужный ему код, поэтому злоумышленники прибегают к социальной инженерии при эксплуатации Self XSS.

Тип инъекции **Blind XSS** является частным случаем Stored XSS. Она возникает, когда данные, вводимые злоумышленником, сохраняются на сервере, но отображаются в другой части приложения или вообще в другом приложении, отличном от того, в котором они были введены. **Ключевой момент:** код злоумышленника не обязательно выполнится именно в какой-либо форме, обычно это какой-то внешний сервис.

### Защита от XSS:

Защита от отраженного XSS в первую очередь заключается в том, чтобы избежать использования динамического вредоносного контента из HTTP-запросов для встраивания скриптов в уязвимое приложение. Некоторые подходы к достижению этого включают:
* 	Подтвердить ввод пользователя

Проверка пользовательского ввода/фильтрация контента формирует первую линию защиты от большинства XSS-атак, включая отраженные XSS. Крайне важно рассматривать пользовательский ввод из любого источника как ненадежный и сформулировать механизмы проверки на соответствие семантическим и грамматическим требованиям. Команды безопасности также должны применять белые/черные списки для шаблонов данных, которые должны быть приняты или отклонены. Кроме того, группам контроля качества и администраторам рекомендуется рассматривать данные как от аутентифицированных, так и от общедоступных пользователей как ненадежные входные данные, применяя одни и те же методы очистки входных данных для всех пользователей. 

* 	Избегать динамического контента

Предположим, что приложение использует управляемые пользователем данные как часть своих HTTP-ответов. В этом случае выходные данные должны быть закодированы таким образом, чтобы сервер не интерпретировал их как активное содержимое. Это гарантирует, что любые специальные символы из хранилища данных приложения обрабатываются как содержимое тега HTML, а не как необработанный HTML. Рекомендуется заменить любые значимые динамические символы схемами кодирования объектов HTML для безопасной интерпретации. Разработчикам следует использовать специальные инструменты для включения безопасной таблицы стилей и кодирования скриптов, если динамическое содержимое вставляется в теги <script> и <style>. 
 
* 	Внедрить политику безопасности контента

Надежная политика безопасности содержимого позволяет веб-администраторам/разработчикам контролировать, откуда веб-страница может загружать и выполнять сценарии. Поскольку отраженная атака XSS основана на внедрении злоумышленником вредоносного контента на веб-страницу, CSP предотвращают атаки, указывая источники встроенных сценариев. Большинство современных браузеров поддерживают CSP, что делает их одним из наиболее важных аспектов предотвращения отраженных XSS-атак.

* 	Использовать инструмент сканирования уязвимостей

Инструменты сканирования уязвимостей автоматически тестируют веб-приложения и лежащий в их основе исходный код для выявления слабых в безопасности, которые могут привести к успешному выполнению XSS-атак. Crashtest Security Suite включает инструмент XSS, который может сканировать JavaScript и веб-приложения на наличие уязвимостей, таких как XSS, без ложных срабатываний.

## Практика (данная практика из блока уязвимостей metasploitable 3) 

### Задание 1.
Уязвимость XSS (Stored) проекта DVWA на простом (Low) уровне сложности. 

Перейдем на страницу XSS (Stored) проекта DVWA:
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/1.png)

Попробуем отправить в качестве сообщения HTML-теги:
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/2.png)

Видим, что в поле Message отобразился отформатированный тегом h1 текст. Это означает, что текст вместе с форматированием сохраняется на сервере и возвращается пользователю отформатированным:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/3.png)

Теперь попробуем сохранить на странице скрипт <script>alert(document.cookie)</script>: 
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/4.png)

Видим всплывающее окно и куки, т. е. XSS есть:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/5.png)

Можно теперь зайти на страницу несколько раз и увидеть результат выполнения скрипта:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/6.png)

Если открыть исходный код страницы, в нем можно найти те записи, которые есть в таблице, прямо вместе с тегами:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/7.png)

    Как мы можем видеть, исполняемый код попадает и сохраняется на сервере именно таким, каким он был отправлен на сервер, даже сохраняются теги. Когда страница будет возвращена пользователю, скрипт будет выполнен. 
    В данной атаке мы использовали следующий вектор атаки: <script>payload</script>, вместо payload был использован alert(document.cookie).
    Модель безопасности в Интернете базируется на политике одинакового источника. Политика одинакового источника (same-origin policy) определяет как документ или скрипт, загруженный из одного источника (origin), может взаимодействовать с ресурсом из другого источника. Это помогает изолировать потенциально вредоносные документы, снижая количество возможных векторов атак.
XSS позволяет обойти SOP. Поэтому для защиты от атак Reflected XSS необходимо выполнить следующее: 
* Внедрить политику безопасности контента Content Security Policy (CSP)
* Производить проверку (фильтрацию) данных, которые передаются	
Также в некоторых случаях необходимо использование парсеров. Существует достаточное количество библиотек для парсинга, поэтому найти и использовать подходящий, не должно быть большой проблемой.

### Задание 2.
Уязвимость XSS (Reflected) проекта DVWA на простом (Low) уровне сложности. 

Перейдем на страницу XSS (Reflected) проекта DVWA (вводимые данные не проверяются):

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/8.png)

Попробуем передать туда строку и найти ее в исходном коде страницы, которую вернет сервер:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/9.png)

Посмотрим, что отобразилось в выводе приветствия:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/10.png)

Если открыть исходный код страницы, мы можем найти введенную строку:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/11.png)

Попробуем передать в уязвимый параметр скрипт такого вида: <script>alert(document.cookie)</script> и посмотрим, что получится:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/12.png)

Браузер вернул куки:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/13.png)

Теперь снова посмотрим на исходный код возвращенной страницы:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/14.png)

Для защиты от данного типа необходимо выполнить следующее: 

* Внедрить политику безопасности контента Content Security Policy (CSP)
* Производить проверку (фильтрацию) данных, которые передаются

### Задание 3.
Уязвимость XSS (DOM) проекта DVWA на простом (Low) уровне сложности.

Перейдем на страницу XSS (DOM) проекта DVWA:
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/15.png)

Посмотрев исходники данной страницы, видим, что никакой защиты нет:
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/16.png)

Протестируем нашу страницу, нажав на кнопку «Select»:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/17.png)

Видно, что ссылка изменилась, данные передаются методом «GET». В адресной строке URL мы можем попробовать ввести вредоносный код:
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/18.png)

Вместо слова «English» введем простой скрипт на JavaScript, например, скрипт с alert: <script>alert('Hello World!')</script>, и он выводит следующее всплывающее окно на странице:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/19.png)

### Задание 4.
Наличие XSS вектора, который использует событие onerror, на странице  XSS – Reflected GET проекта bWAPP.

Перейдем на страницу XSS – Reflected GET проекта bWAPP:
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/20.png)

Реализуем простой HTML-контекст, используя событие onerror. Контекст возникает в теле существующего HTML-тега или в начале и в конце страницы вне тега <html>. В этом контексте вместо данных можно вписать валидный HTML любого рода, и он немедленно будет воспроизведен браузером. Например, такой: <img src=x onerror= alert(document.cookie)>:
![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/21.png)

Это и есть простой HTML-контекст внедрения XSS. В рамках него пользовательский ввод будет выполнен с выполнением всего форматирования:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/22.png)

Для защиты от данного типа необходимо выполнить следующее:
*   Внедрить политику безопасности контента Content Security Policy (CSP)
*  	Производить проверку (фильтрацию) данных, которые передаются

### Задание 5.
Уязвимость XSS на странице XSS – Stored (Coookies) проекта bWAPP на простом (Low) уровне сложности.

Перейдем на страницу XSS – Stored (Coookies) проекта bWAPP:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/23.png)

Настроим Proxy в браузере:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/24.png)

Запустим утилиту BurpSuite:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/25.png)

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/26.png)

На сайте выберем любимый жанр (например, Science Fiction):

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/27.png)

Перейдем в BurpSuite:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/28.png)

Поменяем выбранный жанр sci-fi на Comedy (при этом в cookie пока нет значения movie_genry) и отправим запрос (Forward):

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/29.png)

Выберем снова жанр:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/30.png)

Как мы видим, жанр Comedy отобразился в cookie:

![image](https://github.com/AnaktaCTF/CTFReports/blob/main/zadnepryanskayaalicia/materials/31.png)


